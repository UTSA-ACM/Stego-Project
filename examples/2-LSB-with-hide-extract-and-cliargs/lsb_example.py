# -*- coding: utf-8 -*-
"""lsb-example.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IgFpkhsNgr7wOT288JyjryXeRmtlepTy
"""

# this is how you can upload your test files
# I just used a 4x4 (16 pixel) white image to really show the color differences
from google.colab import files

uploaded = files.upload()

# Our project is going to be able to do several functions:
# - user input processing
#   - processing user arguments
#   - preparing input file
#   - turning the message into bits
# - hiding
#   - (maybe) calculating capacity
#   - writing over bits in input image
#   - saving output image
# - extracting
#   - reading bits in image
#   - displaying message

# you can install the bitarray package using this
!pip install bitarray

# we are now importing the Python Imaging Library (PIL) to manipulate images, and the bitarray class to more easily convert to and from raw bits
from PIL import Image
from bitarray import bitarray

import argparse

# this will turn a string into bits (Python message generator)
def message_generator(message):
  # turns the string into a list of bits (so we can hide it)
  ba = bitarray()
  ba.frombytes(message.encode('utf-8'))

  # now returns each bit in the message one by one
  for bit in ba:
    yield bit

# here we define the file names we are loading and writing to, and open the image
OLD_FILE = "./white-4-by-4.png"
NEW_FILE = "./new-white-4-by-4.png"

def parse_user_input():
  """
  parser = argparse.ArgumentParser()

  # GENERAL OPTIONS
  parser.add_argument("-p", "--operation", action="store", type=str,
                      choices=["hide", "extract", "test"], default="hide",
                      help="either hides, extracts, or runs hiding and extracting")

  # HIDING OPTIONS

  parser.add_argument("-i", "--input_file", type=str, help="input file to hide in", default=OLD_FILE)
  parser.add_argument("-o", "--output_file", type=str, help="output file to put hidden message bits", default=NEW_FILE)

  parser.add_argument("-m", "--message", action="store", type=str, default="Hello!",
                      help="the message to hide")

  parser.add_argument("-r", "--red-bits", action="store",
                      type=int, default=1,
                      help="bits to hide in first component")
  parser.add_argument("-g", "--green-bits", action="store",
                      type=int, default=1,
                      help="bits to hide in second component")
  parser.add_argument("-b", "--blue-bits", action="store",
                      type=int, default=1,
                      help="bits to hide in third component")
  

  args = parser.parse_args()
  return vars(args)
  """
  args = {
      "operation": "hide",
      "input_file": OLD_FILE,
      "output_file": NEW_FILE,
      "message": "hello!",
      "red_bits": 3,
      "green_bits": 1,
      "blue_bits": 1,
  }

  return args

def hide(input_file, output_file, message, red_bits, green_bits, blue_bits, **kwargs):

  # opens the file
  img = Image.open(input_file)
  
  # the new pixel values
  new_data = []

  for rgb_pair in img.getdata():
    red = rgb_pair[0]
    green = rgb_pair[1]
    blue = rgb_pair[2]

    # create the bitarrays (the arrays of bits, the 1s and 0s that make up computer values)
    # NOTE: the 'format(COLOR, "08b")' creates a string of bits that a bitarray can interpret
    # if you're confused about it, just uncomment this:
    red_ba = bitarray(format(red, "08b"))
    green_ba = bitarray(format(green, "08b"))
    blue_ba = bitarray(format(blue, "08b"))

    # defines some lists so its easier to refer to stuff
    color_bas = [red_ba, green_ba, blue_ba]
    bits_to_hide = [red_bits, green_bits, blue_bits]

    # iterates (goes over) each bitarray, making the last "LSB_BITS_TO_ZERO" bits 0 in each bitarray
    for color_ba, bits_to_hide in zip(color_bas, bits_to_hide):
      print(color_ba)
      print(bits_to_hide)

      # for each bit to zero out, we do so (the range loop starts at 1 and goes to LSB_BITS_TO_ZERO)
      for bit_to_hide in range(1, bits_to_hide + 1):

        msg_bit = next(message)
    
        # remember, negative list indexes in python mean going backwards in the list
        # think of it like the list wraps around, so the -1 is the last element, -2 is the 2nd to last, etc.
        # if we didn't make bit to zero negative, we would instead be modifying the most significant bit (check out what happens when you do this!)
        color_ba[-bit_to_hide] = msg_bit

    # here we ust print off the bitarray to confirm we've done everything right
    print(f"red ba: {red_ba} green_ba {green_ba}")

    """

    # now we can convert the bitarrays back to integers
    new_rgb_value = []
    for ba in [red_ba, green_ba, blue_ba]:
      
      # this is super convoluted, so dont worry about it too much
      # Basically, we make the bitarray bytes, then load the bytes into an integer
      new_color_int = int.from_bytes(ba.tobytes(), "big")
      new_rgb_value.append(new_color_int)

    # lastly, we can check our new RGB value and then add it to the list of image pixels
    print(f"Here's my modified pixel: Red: {new_rgb_value[0]} Blue: {new_rgb_value[1]} Blue: {new_rgb_value[2]}")

    # NOTE: we just have to make this a tuple (basically a list that you can't modify)
    # this doesn't really change anything, just a PIL quirk
    new_data.append(tuple(new_rgb_val    for ba in [red_ba, green_ba, blue_ba]:
ue))
    """

main()

def extract():
  ...

def main():
  args = parse_user_input()

  # turns our string message into a bit by bit generator
  args["message"] = message_generator(args["message"])

  if args["operation"] == "hide":
    hide(**args)
  elif args["operation"] == "extract":
    extract(**args)

main()

